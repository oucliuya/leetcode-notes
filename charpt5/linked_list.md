# 5.3. Linked List

## 1 基本特征

Def：链表是一种实现非连续存储的方式。 链表由一系列结点组成，它们可以不连续存储。每一个结点包含两部分：一部分是数据域，存储本结点的数据；另一部分是指针域，存储下一个结点的地址。

**优点：**

1. 它的插入/删除时间复杂度是常数```O(1)```， 远远优于顺序存储的数组。
2. 可以动态地管理内存，无需像数组一样预先分配一段连续的内存。链表插入删除可动态地分配和回收内存，提高内存利用效率。

**缺点：**

1. 顺序表（数组）的每个元素的存取时间复杂度是相等的，都是```O(1)```， 而链表的节点存取的复杂度是跟结点的位置相关的，位置越靠后存取的时间消耗越大，最差的情况是最后一个节点，复杂度为```O(n)```
2. 相比于顺序表（数组），链表的每个结点增加了一个指针域，在空间上有额外的消耗。

**数组和链表的比较：**

|              | array                                                    | linked list                                                  |
| ------------ | -------------------------------------------------------- | ------------------------------------------------------------ |
| 插入/删除    | 可能会很慢，取决于位置,最差为O(n)                        | 快，复杂度为常数O(1)                                         |
| 搜索（存取） | 快，复杂度为常数O(1)                                     | 慢，取决于位置，最差为O(n)                                   |
| 伸缩         | 长度固定，不好伸缩                                       | 长度是动态的，容易伸缩                                       |
| 内存分配     | 在创建时分配好连续的内存，即便用不满，这些内存仍然被占用 | 内存是在运行时动态分配的，且使用非连续内存，而且可伸缩       |
| 查找元素     | 查找元素很快，因为内存是连续的，可以使用二分查找         | 查找元素慢，必须遍历。不可使用二分查找                       |
|              | 当你知道列表的长度，而且需要经常进行随机存取时使用数组   | 当你不知道列表的长度，而且需要经常进行插入/删除操作，并且不需要经常进行随机存取时使用链表 |

**常见的链表种类：**

* 单链表 （单一方向）
* 双链表 （双向）
* 循环链表

**链表的基本操作：**

* 末端插入 — 新建一个节点p, p.next 指向null， 末端结点的next指向p
* 头部插入 — 新建一个节点p, p.next 指向头部
* 删除 — 在链表中删除指定位置，主要工作是找到这个元素（遍历）
* 头部删除 — 直接删掉，返回二个元素的指针作为整个链表的头部
* 搜索 — 判断给定元素是否存在于链表中， 遍历
* 判空 — 判断链表是否为空， 头结点p==null即为空

## 2 常见题型

### 1 哨兵结点

几乎所有链表问题都可以使用一个哨兵结点，来简化边界条件。比如给你一个链表p，如果头结点会发生变化，等运行完程序后，你如何再返回这个p呢？简单办法是在操作结点前先给p添加一个哨兵结点 ```pre.next = p```，等程序运行完，```return pre.next```即为结果。

### 2 链表翻转

如第24题，每两个相邻的元素交换位置。通常使用递归或者双指针的方法。

如果给以个链表 p， 要获得它的翻转链表。只需从头到尾遍历旧链表p，并使用头部插入的方式生成链表q。 q就是p的反序链表。

### 3 链表找交点



### 4 检查链表中是否有环



### 5 找到距离尾部为n的结点



### 6 删除链表中的重复元素

第83题，删除重复元素。 方法是：遍历，两层循环。

## 参考

[码农找工作之：算法面试前必知必会的8种数据结构](https://zhuanlan.zhihu.com/p/90789026)